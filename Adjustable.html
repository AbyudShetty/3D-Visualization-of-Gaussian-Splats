<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>First-Person Marble Navigation</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000000; font-family: sans-serif; }
    canvas { display: block; }
    #info {
      position: absolute; top: 10px; left: 10px;
      color: white; background: rgba(0,0,0,0.7); 
      padding: 10px 15px; border-radius: 8px;
      max-width: 300px;
    }
    #controls {
      position: absolute; top: 10px; right: 10px;
      color: white; background: rgba(0,0,0,0.7);
      padding: 15px; border-radius: 8px;
      width: 250px;
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 13px;
      font-weight: bold;
    }
    input[type="range"] {
      width: 100%;
      margin: 5px 0;
    }
    input[type="number"] {
      width: 60px;
      padding: 4px;
      margin: 2px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      border-radius: 4px;
    }
    .boundary-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 5px;
      font-size: 11px;
    }
    .boundary-inputs label {
      font-weight: normal;
      margin-bottom: 2px;
    }
    button {
      padding: 6px 12px;
      background: rgba(100,150,255,0.8);
      border: none;
      border-radius: 4px;
      color: white;
      cursor: pointer;
      font-size: 12px;
      margin-top: 5px;
    }
    button:hover {
      background: rgba(120,170,255,0.9);
    }
    .sensitivity-value {
      display: inline-block;
      margin-left: 10px;
      font-weight: bold;
      color: #4af;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/",
        "@sparkjsdev/spark": "https://cdn.jsdelivr.net/npm/@sparkjsdev/spark@latest/dist/spark.module.js"
      }
    }
  </script>
</head>
<body>
<div id="info">
  <b>Controls:</b><br>
  Click to lock pointer<br>
  <b>WASD</b> - Move<br>
  <b>Mouse</b> - Look around<br>
  <b>QE</b> - Up/Down
</div>

<div id="controls">
  <div class="control-group">
    <label>
      Mouse Sensitivity
      <span class="sensitivity-value" id="sensValue">30%</span>
    </label>
    <input type="range" id="sensitivity" min="5" max="100" value="30" step="5">
  </div>
  
  <div class="control-group">
    <label>Current Position</label>
    <div style="font-size: 12px; color: #4af; line-height: 1.6;">
      X: <span id="posX">0.0</span><br>
      Y: <span id="posY">1.6</span><br>
      Z: <span id="posZ">5.0</span>
    </div>
  </div>
  
  <div class="control-group">
    <label>Movement Boundaries</label>
    <div class="boundary-inputs">
      <label>Min X: <input type="number" id="minX" step="0.5"></label>
      <label>Max X: <input type="number" id="maxX" step="0.5"></label>
      <label>Min Y: <input type="number" id="minY" step="0.5"></label>
      <label>Max Y: <input type="number" id="maxY" step="0.5"></label>
      <label>Min Z: <input type="number" id="minZ" step="0.5"></label>
      <label>Max Z: <input type="number" id="maxZ" step="0.5"></label>
    </div>
    <button id="applyBounds">Apply Boundaries</button>
    <button id="resetBounds">Reset to Auto</button>
  </div>
</div>

<script type="module">
  import * as THREE from "three";
  import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
  import { SplatMesh } from "@sparkjsdev/spark";

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0);
  camera.rotation.y = 0; // Facing towards -Z axis

  // Load Marble world
  const world = new SplatMesh({ url: "./ParkingLot.spz" });
  world.rotation.z = Math.PI;
  world.rotation.y = Math.PI; 
  scene.add(world);

  // Calculate bounding box for movement restrictions
  const boundingBox = new THREE.Box3();
  let autoBoundaries = { minX: -10, maxX: 10, minY: 0, maxY: 10, minZ: -10, maxZ: 10 };
  let boundaries = { ...autoBoundaries };
  
  setTimeout(() => {
    world.traverse((child) => {
      if (child.geometry) {
        child.geometry.computeBoundingBox();
        boundingBox.expandByObject(child);
      }
    });
    
    const margin = 0.5;
    if (boundingBox.min.x !== Infinity) {
      autoBoundaries = {
        minX: boundingBox.min.x + margin,
        maxX: boundingBox.max.x - margin,
        minY: boundingBox.min.y + margin,
        maxY: boundingBox.max.y - margin,
        minZ: boundingBox.min.z + margin,
        maxZ: boundingBox.max.z - margin
      };
      boundaries = { ...autoBoundaries };
      updateBoundaryInputs();
    }
  }, 500);

  // First-person controls with adjustable sensitivity
  const controls = new PointerLockControls(camera, document.body);
  let sensitivityFactor = 0.3;
  
  controls.onMouseMove = function(event) {
    if (!controls.isLocked) return;
    
    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
    
    const euler = controls.getObject().rotation;
    const PI_2 = Math.PI / 2;
    
    euler.y -= movementX * 0.002 * sensitivityFactor;
    euler.x -= movementY * 0.002 * sensitivityFactor;
    euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
  };
  
  document.body.addEventListener("click", () => controls.lock());

  // UI Controls
  const sensSlider = document.getElementById('sensitivity');
  const sensValue = document.getElementById('sensValue');
  
  sensSlider.addEventListener('input', (e) => {
    sensitivityFactor = e.target.value / 100;
    sensValue.textContent = e.target.value + '%';
  });

  function updateBoundaryInputs() {
    document.getElementById('minX').value = boundaries.minX.toFixed(1);
    document.getElementById('maxX').value = boundaries.maxX.toFixed(1);
    document.getElementById('minY').value = boundaries.minY.toFixed(1);
    document.getElementById('maxY').value = boundaries.maxY.toFixed(1);
    document.getElementById('minZ').value = boundaries.minZ.toFixed(1);
    document.getElementById('maxZ').value = boundaries.maxZ.toFixed(1);
  }
  updateBoundaryInputs();

  document.getElementById('applyBounds').addEventListener('click', () => {
    boundaries.minX = parseFloat(document.getElementById('minX').value);
    boundaries.maxX = parseFloat(document.getElementById('maxX').value);
    boundaries.minY = parseFloat(document.getElementById('minY').value);
    boundaries.maxY = parseFloat(document.getElementById('maxY').value);
    boundaries.minZ = parseFloat(document.getElementById('minZ').value);
    boundaries.maxZ = parseFloat(document.getElementById('maxZ').value);
  });

  document.getElementById('resetBounds').addEventListener('click', () => {
    boundaries = { ...autoBoundaries };
    updateBoundaryInputs();
  });

  // Movement state
  const move = { forward: false, backward: false, left: false, right: false, up: false, down: false };
  const velocity = new THREE.Vector3();

  document.addEventListener("keydown", e => {
    if (e.code === "KeyW") move.forward = true;
    if (e.code === "KeyS") move.backward = true;
    if (e.code === "KeyA") move.left = true;
    if (e.code === "KeyD") move.right = true;
    if (e.code === "KeyQ") move.down = true;
    if (e.code === "KeyE") move.up = true;
  });
  document.addEventListener("keyup", e => {
    if (e.code === "KeyW") move.forward = false;
    if (e.code === "KeyS") move.backward = false;
    if (e.code === "KeyA") move.left = false;
    if (e.code === "KeyD") move.right = false;
    if (e.code === "KeyQ") move.down = false;
    if (e.code === "KeyE") move.up = false;
  });

  // Basic light
  const light = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(light);

  // Render loop
  let prevTime = performance.now();

  function animate() {
    requestAnimationFrame(animate);

    const time = performance.now();
    const delta = (time - prevTime) / 1000;
    prevTime = time;

    if (controls.isLocked) {
      const dir = new THREE.Vector3();
      const right = new THREE.Vector3();
      camera.getWorldDirection(dir);
      dir.y = 0;
      dir.normalize();
      right.crossVectors(dir, camera.up).normalize();

      const accel = new THREE.Vector3();
      const speed = 5.0;
      const damping = 10.0;

      if (move.forward) accel.addScaledVector(dir, speed * delta);
      if (move.backward) accel.addScaledVector(dir, -speed * delta);
      if (move.left) accel.addScaledVector(right, -speed * delta);
      if (move.right) accel.addScaledVector(right, speed * delta);

      if (move.up) accel.y += speed * delta;
      if (move.down) accel.y -= speed * delta;

      velocity.add(accel);
      velocity.multiplyScalar(1 - Math.min(damping * delta, 1));

      // Calculate new position
      const newPosition = camera.position.clone().add(velocity);

      // Clamp position to boundaries
      newPosition.x = Math.max(boundaries.minX, Math.min(boundaries.maxX, newPosition.x));
      newPosition.y = Math.max(boundaries.minY, Math.min(boundaries.maxY, newPosition.y));
      newPosition.z = Math.max(boundaries.minZ, Math.min(boundaries.maxZ, newPosition.z));

      // Stop velocity if hitting boundary
      if (newPosition.x === boundaries.minX || newPosition.x === boundaries.maxX) velocity.x = 0;
      if (newPosition.y === boundaries.minY || newPosition.y === boundaries.maxY) velocity.y = 0;
      if (newPosition.z === boundaries.minZ || newPosition.z === boundaries.maxZ) velocity.z = 0;

      camera.position.copy(newPosition);
      
      // Update position display
      document.getElementById('posX').textContent = camera.position.x.toFixed(2);
      document.getElementById('posY').textContent = camera.position.y.toFixed(2);
      document.getElementById('posZ').textContent = camera.position.z.toFixed(2);
    }
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>